<?php
namespace Hbase;

/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * TCell - Used to transport a cell value (byte[]) and the timestamp it was
 * stored with together as a result for get and getRow methods. This promotes
 * the timestamp of a cell to a first-class value, making it easy to take
 * note of temporal data. Cell is used all the way from HStore up to HTable.
 */
class TCell {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var string
   */
  public $value = null;
  /**
   * @var int
   */
  public $timestamp = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'TCell';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TCell');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 2);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An HColumnDescriptor contains information about a column family
 * such as the number of versions, compression settings, etc. It is
 * used as input when creating a table or adding a column.
 */
class ColumnDescriptor {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'name',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'maxVersions',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    3 => array(
      'var' => 'compression',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'inMemory',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    5 => array(
      'var' => 'bloomFilterType',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    6 => array(
      'var' => 'bloomFilterVectorSize',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    7 => array(
      'var' => 'bloomFilterNbHashes',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    8 => array(
      'var' => 'blockCacheEnabled',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    9 => array(
      'var' => 'timeToLive',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $maxVersions = 3;
  /**
   * @var string
   */
  public $compression = "NONE";
  /**
   * @var bool
   */
  public $inMemory = false;
  /**
   * @var string
   */
  public $bloomFilterType = "NONE";
  /**
   * @var int
   */
  public $bloomFilterVectorSize = 0;
  /**
   * @var int
   */
  public $bloomFilterNbHashes = 0;
  /**
   * @var bool
   */
  public $blockCacheEnabled = false;
  /**
   * @var int
   */
  public $timeToLive = 2147483647;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['maxVersions'])) {
        $this->maxVersions = $vals['maxVersions'];
      }
      if (isset($vals['compression'])) {
        $this->compression = $vals['compression'];
      }
      if (isset($vals['inMemory'])) {
        $this->inMemory = $vals['inMemory'];
      }
      if (isset($vals['bloomFilterType'])) {
        $this->bloomFilterType = $vals['bloomFilterType'];
      }
      if (isset($vals['bloomFilterVectorSize'])) {
        $this->bloomFilterVectorSize = $vals['bloomFilterVectorSize'];
      }
      if (isset($vals['bloomFilterNbHashes'])) {
        $this->bloomFilterNbHashes = $vals['bloomFilterNbHashes'];
      }
      if (isset($vals['blockCacheEnabled'])) {
        $this->blockCacheEnabled = $vals['blockCacheEnabled'];
      }
      if (isset($vals['timeToLive'])) {
        $this->timeToLive = $vals['timeToLive'];
      }
    }
  }

  public function getName() {
    return 'ColumnDescriptor';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxVersions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->compression);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->inMemory);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bloomFilterType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->bloomFilterVectorSize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->bloomFilterNbHashes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->blockCacheEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->timeToLive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ColumnDescriptor');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxVersions !== null) {
      $xfer += $output->writeFieldBegin('maxVersions', TType::I32, 2);
      $xfer += $output->writeI32($this->maxVersions);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->compression !== null) {
      $xfer += $output->writeFieldBegin('compression', TType::STRING, 3);
      $xfer += $output->writeString($this->compression);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inMemory !== null) {
      $xfer += $output->writeFieldBegin('inMemory', TType::BOOL, 4);
      $xfer += $output->writeBool($this->inMemory);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bloomFilterType !== null) {
      $xfer += $output->writeFieldBegin('bloomFilterType', TType::STRING, 5);
      $xfer += $output->writeString($this->bloomFilterType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bloomFilterVectorSize !== null) {
      $xfer += $output->writeFieldBegin('bloomFilterVectorSize', TType::I32, 6);
      $xfer += $output->writeI32($this->bloomFilterVectorSize);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bloomFilterNbHashes !== null) {
      $xfer += $output->writeFieldBegin('bloomFilterNbHashes', TType::I32, 7);
      $xfer += $output->writeI32($this->bloomFilterNbHashes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->blockCacheEnabled !== null) {
      $xfer += $output->writeFieldBegin('blockCacheEnabled', TType::BOOL, 8);
      $xfer += $output->writeBool($this->blockCacheEnabled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timeToLive !== null) {
      $xfer += $output->writeFieldBegin('timeToLive', TType::I32, 9);
      $xfer += $output->writeI32($this->timeToLive);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A TRegionInfo contains information about an HTable region.
 */
class TRegionInfo {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'startKey',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'endKey',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'id',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'name',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    5 => array(
      'var' => 'version',
      'isRequired' => false,
      'type' => TType::BYTE,
      ),
    6 => array(
      'var' => 'serverName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    7 => array(
      'var' => 'port',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    );

  /**
   * @var string
   */
  public $startKey = null;
  /**
   * @var string
   */
  public $endKey = null;
  /**
   * @var int
   */
  public $id = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $version = null;
  /**
   * @var string
   */
  public $serverName = null;
  /**
   * @var int
   */
  public $port = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['startKey'])) {
        $this->startKey = $vals['startKey'];
      }
      if (isset($vals['endKey'])) {
        $this->endKey = $vals['endKey'];
      }
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['serverName'])) {
        $this->serverName = $vals['serverName'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
    }
  }

  public function getName() {
    return 'TRegionInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serverName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRegionInfo');
    if ($this->startKey !== null) {
      $xfer += $output->writeFieldBegin('startKey', TType::STRING, 1);
      $xfer += $output->writeString($this->startKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endKey !== null) {
      $xfer += $output->writeFieldBegin('endKey', TType::STRING, 2);
      $xfer += $output->writeString($this->endKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 3);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 4);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::BYTE, 5);
      $xfer += $output->writeByte($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serverName !== null) {
      $xfer += $output->writeFieldBegin('serverName', TType::STRING, 6);
      $xfer += $output->writeString($this->serverName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 7);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A Mutation object is used to either update or delete a column-value.
 */
class Mutation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'isDelete',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    2 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'writeToWAL',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    );

  /**
   * @var bool
   */
  public $isDelete = false;
  /**
   * @var string
   */
  public $column = null;
  /**
   * @var string
   */
  public $value = null;
  /**
   * @var bool
   */
  public $writeToWAL = true;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['isDelete'])) {
        $this->isDelete = $vals['isDelete'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['writeToWAL'])) {
        $this->writeToWAL = $vals['writeToWAL'];
      }
    }
  }

  public function getName() {
    return 'Mutation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isDelete);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->writeToWAL);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Mutation');
    if ($this->isDelete !== null) {
      $xfer += $output->writeFieldBegin('isDelete', TType::BOOL, 1);
      $xfer += $output->writeBool($this->isDelete);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 2);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->writeToWAL !== null) {
      $xfer += $output->writeFieldBegin('writeToWAL', TType::BOOL, 4);
      $xfer += $output->writeBool($this->writeToWAL);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A BatchMutation object is used to apply a number of Mutations to a single row.
 */
class BatchMutation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'mutations',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\Mutation',
        ),
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var \Hbase\Mutation[]
   */
  public $mutations = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
    }
  }

  public function getName() {
    return 'BatchMutation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \Hbase\Mutation();
              $xfer += $elem5->read($input);
              $this->mutations []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BatchMutation');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * For increments that are not incrementColumnValue
 * equivalents.
 */
class TIncrement {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'column',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'ammount',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var string
   */
  public $table = null;
  /**
   * @var string
   */
  public $row = null;
  /**
   * @var string
   */
  public $column = null;
  /**
   * @var int
   */
  public $ammount = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['ammount'])) {
        $this->ammount = $vals['ammount'];
      }
    }
  }

  public function getName() {
    return 'TIncrement';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->ammount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TIncrement');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ammount !== null) {
      $xfer += $output->writeFieldBegin('ammount', TType::I64, 4);
      $xfer += $output->writeI64($this->ammount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Holds column name and the cell.
 */
class TColumn {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'columnName',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'cell',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Hbase\TCell',
      ),
    );

  /**
   * @var string
   */
  public $columnName = null;
  /**
   * @var \Hbase\TCell
   */
  public $cell = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['columnName'])) {
        $this->columnName = $vals['columnName'];
      }
      if (isset($vals['cell'])) {
        $this->cell = $vals['cell'];
      }
    }
  }

  public function getName() {
    return 'TColumn';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->cell = new \Hbase\TCell();
            $xfer += $this->cell->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TColumn');
    if ($this->columnName !== null) {
      $xfer += $output->writeFieldBegin('columnName', TType::STRING, 1);
      $xfer += $output->writeString($this->columnName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cell !== null) {
      if (!is_object($this->cell)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cell', TType::STRUCT, 2);
      $xfer += $this->cell->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Holds row name and then a map of columns to cells.
 */
class TRowResult {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::MAP,
      'ktype' => TType::STRING,
      'vtype' => TType::STRUCT,
      'key' => array(
        'type' => TType::STRING,
      ),
      'val' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TCell',
        ),
      ),
    3 => array(
      'var' => 'sortedColumns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Hbase\TColumn',
        ),
      ),
    );

  /**
   * @var string
   */
  public $row = null;
  /**
   * @var array
   */
  public $columns = null;
  /**
   * @var \Hbase\TColumn[]
   */
  public $sortedColumns = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['sortedColumns'])) {
        $this->sortedColumns = $vals['sortedColumns'];
      }
    }
  }

  public function getName() {
    return 'TRowResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->columns = array();
            $_size7 = 0;
            $_ktype8 = 0;
            $_vtype9 = 0;
            $xfer += $input->readMapBegin($_ktype8, $_vtype9, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $key12 = '';
              $val13 = new \Hbase\TCell();
              $xfer += $input->readString($key12);
              $val13 = new \Hbase\TCell();
              $xfer += $val13->read($input);
              $this->columns[$key12] = $val13;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->sortedColumns = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $elem19 = new \Hbase\TColumn();
              $xfer += $elem19->read($input);
              $this->sortedColumns []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TRowResult');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->columns));
        {
          foreach ($this->columns as $kiter20 => $viter21)
          {
            $xfer += $output->writeString($kiter20);
            $xfer += $viter21->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortedColumns !== null) {
      if (!is_array($this->sortedColumns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortedColumns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortedColumns));
        {
          foreach ($this->sortedColumns as $iter22)
          {
            $xfer += $iter22->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A Scan object is used to specify scanner parameters when opening a scanner.
 */
class TScan {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'startRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'stopRow',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    4 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    5 => array(
      'var' => 'caching',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    6 => array(
      'var' => 'filterString',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    7 => array(
      'var' => 'batchSize',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    8 => array(
      'var' => 'sortColumns',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    9 => array(
      'var' => 'reversed',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    );

  /**
   * @var string
   */
  public $startRow = null;
  /**
   * @var string
   */
  public $stopRow = null;
  /**
   * @var int
   */
  public $timestamp = null;
  /**
   * @var string[]
   */
  public $columns = null;
  /**
   * @var int
   */
  public $caching = null;
  /**
   * @var string
   */
  public $filterString = null;
  /**
   * @var int
   */
  public $batchSize = null;
  /**
   * @var bool
   */
  public $sortColumns = null;
  /**
   * @var bool
   */
  public $reversed = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['caching'])) {
        $this->caching = $vals['caching'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
      if (isset($vals['batchSize'])) {
        $this->batchSize = $vals['batchSize'];
      }
      if (isset($vals['sortColumns'])) {
        $this->sortColumns = $vals['sortColumns'];
      }
      if (isset($vals['reversed'])) {
        $this->reversed = $vals['reversed'];
      }
    }
  }

  public function getName() {
    return 'TScan';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size23 = 0;
            $_etype26 = 0;
            $xfer += $input->readListBegin($_etype26, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $elem28 = null;
              $xfer += $input->readString($elem28);
              $this->columns []= $elem28;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->caching);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->batchSize);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->sortColumns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->reversed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TScan');
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 1);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 2);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter29)
          {
            $xfer += $output->writeString($iter29);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->caching !== null) {
      $xfer += $output->writeFieldBegin('caching', TType::I32, 5);
      $xfer += $output->writeI32($this->caching);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 6);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->batchSize !== null) {
      $xfer += $output->writeFieldBegin('batchSize', TType::I32, 7);
      $xfer += $output->writeI32($this->batchSize);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortColumns !== null) {
      $xfer += $output->writeFieldBegin('sortColumns', TType::BOOL, 8);
      $xfer += $output->writeBool($this->sortColumns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reversed !== null) {
      $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 9);
      $xfer += $output->writeBool($this->reversed);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An Append object is used to specify the parameters for performing the append operation.
 */
class TAppend {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'table',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'row',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'columns',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    4 => array(
      'var' => 'values',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRING,
      'elem' => array(
        'type' => TType::STRING,
        ),
      ),
    );

  /**
   * @var string
   */
  public $table = null;
  /**
   * @var string
   */
  public $row = null;
  /**
   * @var string[]
   */
  public $columns = null;
  /**
   * @var string[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['table'])) {
        $this->table = $vals['table'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'TAppend';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size30 = 0;
            $_etype33 = 0;
            $xfer += $input->readListBegin($_etype33, $_size30);
            for ($_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              $elem35 = null;
              $xfer += $input->readString($elem35);
              $this->columns []= $elem35;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size36 = 0;
            $_etype39 = 0;
            $xfer += $input->readListBegin($_etype39, $_size36);
            for ($_i40 = 0; $_i40 < $_size36; ++$_i40)
            {
              $elem41 = null;
              $xfer += $input->readString($elem41);
              $this->values []= $elem41;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TAppend');
    if ($this->table !== null) {
      $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
      $xfer += $output->writeString($this->table);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter42)
          {
            $xfer += $output->writeString($iter42);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->values));
        {
          foreach ($this->values as $iter43)
          {
            $xfer += $output->writeString($iter43);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An IOError exception signals that an error occurred communicating
 * to the Hbase master or an Hbase region server.  Also used to return
 * more general Hbase error conditions.
 */
class IOError extends TException {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'message',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'IOError';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IOError');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An IllegalArgument exception indicates an illegal or invalid
 * argument was passed into a procedure.
 */
class IllegalArgument extends TException {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'message',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'IllegalArgument';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IllegalArgument');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An AlreadyExists exceptions signals that a table with the specified
 * name already exists
 */
class AlreadyExists extends TException {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'message',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'AlreadyExists';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AlreadyExists');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


